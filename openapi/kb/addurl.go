package kb

import (
	"context"
	"fmt"

	"github.com/gin-gonic/gin"
	"github.com/yaoapp/gou/graphrag/utils"
	"github.com/yaoapp/kun/log"
	"github.com/yaoapp/kun/maps"
	"github.com/yaoapp/yao/kb"
	"github.com/yaoapp/yao/openapi/response"
)

// AddURLProcess processes a URL addition request with business logic only
// This function is Gin-agnostic and can be used for both sync and async operations
func AddURLProcess(ctx context.Context, req *AddURLRequest, jobID ...string) error {
	// Check if kb.Instance is available
	if kb.Instance == nil {
		return fmt.Errorf("knowledge base not initialized")
	}

	// Validate request
	if err := req.Validate(); err != nil {
		return err
	}

	// DocID should be generated by the caller before calling this function
	if req.DocID == "" {
		return fmt.Errorf("document ID is required")
	}

	// Get KB config
	config, err := kb.GetConfig()
	if err != nil {
		return fmt.Errorf("failed to get KB config: %w", err)
	}

	// Prepare document data for database
	documentData := map[string]interface{}{
		"document_id":   req.DocID,
		"collection_id": req.CollectionID,
		"name":          "URL Document",
		"type":          "url",
		"status":        "pending",
		"url":           req.URL,
	}

	// Add job_id if provided (for async operations)
	if len(jobID) > 0 && jobID[0] != "" {
		documentData["job_id"] = jobID[0]
	}

	// Use title from metadata if available
	if req.Metadata != nil {
		if title, ok := req.Metadata["title"].(string); ok && title != "" {
			documentData["name"] = title
		}
	}

	// Add base request fields
	req.BaseUpsertRequest.AddBaseFields(documentData)

	// First create database record
	_, err = config.CreateDocument(maps.MapStrAny(documentData))
	if err != nil {
		return fmt.Errorf("failed to save document metadata: %w", err)
	}

	// Convert request to UpsertOptions
	upsertOptions, err := req.BaseUpsertRequest.ToUpsertOptions()
	if err != nil {
		// Rollback: remove the database record
		if rollbackErr := config.RemoveDocument(req.DocID); rollbackErr != nil {
			log.Error("Failed to rollback document database record: %v", rollbackErr)
		}
		return fmt.Errorf("failed to convert request to upsert options: %w", err)
	}

	// Perform upsert operation with URL
	_, err = kb.Instance.AddURL(ctx, req.URL, upsertOptions)
	if err != nil {
		// Update status to error
		config.UpdateDocument(req.DocID, maps.MapStrAny{"status": "error", "error_message": err.Error()})
		return fmt.Errorf("failed to add URL: %w", err)
	}

	// Update status to completed after successful processing
	if err := config.UpdateDocument(req.DocID, maps.MapStrAny{"status": "completed"}); err != nil {
		log.Error("Failed to update document status to completed: %v", err)
	}

	return nil
}

// addURLWithRequest processes a URL addition with pre-parsed request using Gin context
func addURLWithRequest(c *gin.Context, req *AddURLRequest) {
	// Use the business logic function
	err := AddURLProcess(c.Request.Context(), req)
	if err != nil {
		errorResp := &response.ErrorResponse{
			Code:             response.ErrServerError.Code,
			ErrorDescription: err.Error(),
		}
		response.RespondWithError(c, response.StatusInternalServerError, errorResp)
		return
	}

	// Return success response
	result := gin.H{
		"message":       "URL added successfully",
		"collection_id": req.CollectionID,
		"url":           req.URL,
		"doc_id":        req.DocID,
	}

	response.RespondWithSuccess(c, response.StatusCreated, result)
}

// AddURL adds a URL to a collection
func AddURL(c *gin.Context) {
	var req AddURLRequest

	// Check if kb.Instance is available
	if !checkKBInstance(c) {
		return
	}

	// Parse and bind JSON request
	if err := c.ShouldBindJSON(&req); err != nil {
		errorResp := &response.ErrorResponse{
			Code:             response.ErrInvalidRequest.Code,
			ErrorDescription: "Invalid request format: " + err.Error(),
		}
		response.RespondWithError(c, response.StatusBadRequest, errorResp)
		return
	}

	// Validate request
	if err := req.Validate(); err != nil {
		errorResp := &response.ErrorResponse{
			Code:             response.ErrInvalidRequest.Code,
			ErrorDescription: err.Error(),
		}
		response.RespondWithError(c, response.StatusBadRequest, errorResp)
		return
	}

	// Generate document ID if not provided
	if req.DocID == "" {
		req.DocID = utils.GenDocIDWithCollectionID(req.CollectionID)
	}

	// Process the request
	addURLWithRequest(c, &req)
}

// AddURLAsync adds a URL to a collection asynchronously
func AddURLAsync(c *gin.Context) {
	var req AddURLRequest

	// Parse and bind JSON request
	if err := c.ShouldBindJSON(&req); err != nil {
		errorResp := &response.ErrorResponse{
			Code:             response.ErrInvalidRequest.Code,
			ErrorDescription: "Invalid request format: " + err.Error(),
		}
		response.RespondWithError(c, response.StatusBadRequest, errorResp)
		return
	}

	// Validate request
	if err := req.Validate(); err != nil {
		errorResp := &response.ErrorResponse{
			Code:             response.ErrInvalidRequest.Code,
			ErrorDescription: err.Error(),
		}
		response.RespondWithError(c, response.StatusBadRequest, errorResp)
		return
	}

	// Check if kb.Instance is available
	if !checkKBInstance(c) {
		return
	}

	// Convert request to UpsertOptions (just for validation)
	_, err := getUpsertOptions(c, &req.BaseUpsertRequest)
	if err != nil {
		return
	}

	// Generate document ID if not provided
	if req.DocID == "" {
		req.DocID = utils.GenDocIDWithCollectionID(req.CollectionID)
	}

	// Create and run job
	job := NewJob()
	jobID := job.Run(func() {
		err := AddURLProcess(context.Background(), &req, job.ID)
		if err != nil {
			log.Error("Async URL processing failed: %v", err)
		}
	})

	// Return job_id and doc_id
	response.RespondWithSuccess(c, response.StatusCreated, gin.H{
		"job_id": jobID,
		"doc_id": req.DocID,
	})
}
